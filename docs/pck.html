---
layout: chapter
title: "Actionable Approximations of the Truth"
---
<h1 id="s:pck">7) Actionable Approximations of the Truth</h1>
<blockquote>
<p><strong>After reading this chapter, you will be able to<span>…</span></strong></p>
<ul>
<li>Summarize research on how well learners are doing in introductory computing classes today.</li>
<li>Explain at least three factors that influence how well or how quickly people learn how to program, and give examples of each.</li>
<li>Summarize shortcomings in the ways that novices typically test their software.</li>
<li>Explain when and how to use program visualization to teach introductory programming courses.</li>
<li>Explain why tracing and explaining programs can be a more effective way to teach programming than having learners write programs.</li>
</ul>
</blockquote>
<p><a class="glossref" href="./gloss.html#g:pedagogical-content-knowledge"><strong>Pedagogical content knowledge</strong></a> (PCK) is what stands between an instructor’s knowledge of the problem domain and their general knowledge of teaching. In computing, it includes things like what examples to use when teaching how parameters are passed to a function, or what misconceptions about nesting HTML tags are most common. This chapter summarizes some of the research-based pedagogical content knowledge we have about teaching and learning programming; [<a href="./bib.html#Sent2018">Sent2018</a>] is an up-to-date and more detailed exploration.</p>
<p>Computing education research is still a young discipline: the American Society for Engineering Education was founded in 1893, the National Council of Teachers of Mathematics in 1920, the American Association of Physics Teachers in 1950—and the Computer Science Teachers Association in 2005. The simple truth is that We don’t know as much about how people learn to program as we do about how they learn to read, play a sport, or do basic arithmetic. However, we do know a few things, and conferences like <a href="http://sigcse.org/">SIGCSE</a>, <a href="http://iticse.acm.org/">ITiCSE</a> and <a href="https://icer.hosting.acm.org">ICER</a> are delivering a steady stream of rigorous, insightful studies with immediate practical application.</p>
<p>As with all research, some caution is required to interpret their results. Most of what is presented comes from studying school children and university undergraduates, both because those are the populations that researchers have easiest access to [<a href="./bib.html#Henr2010">Henr2010</a>], and because those are the ages at which people most often learn to program. Less is known about adults learning to program in free-range settings or about people who don’t intend to be computer scientists, but what we do know is included. (For those interested in methods, [<a href="./bib.html#Ihan2016">Ihan2016</a>] summarizes the ones used most often in this kind of research.)</p>
<p>Theories may change as more and better data becomes available, so if this was an academic treatise, it would preface most claims with statements like, “Research may seem to indicate that<span>…</span>” However, as <a href="https://computinged.wordpress.com/2018/06/15/are-you-talking-to-me-interaction-between-teachers-and-researchers-around-evidence-truth-and-decision-making/">Mark Guzdial wrote</a>, actual teachers in actual classrooms have to make decisions regardless of whether research has clear answers yet or not. I have therefore presented actionable approximations of the truth rather than nuanced perhapses.</p>
<p>Finally, some of the conclusions below are based on small populations or short study periods simply because that’s all the researchers could afford. Despite all the hand-wringing by industry and government about there being shortage of programmers, computing education research gets less money each year that is spent on development of a single high-end video game. If you are in a position to change this, or to influence those who can, please do.</p>
<blockquote>
<p><strong>Jargon</strong></p>
<p>Like any specialty, computing education research has its jargon. The term <a class="glossref" href="./gloss.html#g:cs1"><strong>CS1</strong></a> refers to an introductory semester-long programming course in which learners meet variables, loops, and functions for the first time, while <a class="glossref" href="./gloss.html#g:cs2"><strong>CS2</strong></a> refers to a second course that covers basic data structures like stacks and queues. The term <a class="glossref" href="./gloss.html#g:cs0"><strong>CS0</strong></a> is also now being used to refer to an introductory course for people without any prior experience who aren’t intending to continue with computing (at least not right away).</p>
<p>A CS1 course is often useful for undergraduates in other disciplines; a CS2 course designed for computer science learners is usually less relevant for artists, ecologists, and other <a class="glossref" href="./gloss.html#g:end-user-programmer"><strong>end-user programmers</strong></a>, but is sometimes the only next step available at their institution. Full definitions for these terms and others can be found in the <a href="https://www.acm.org/education/curricula-recommendations">ACM Curriculum Guidelines</a>.</p>
</blockquote>
<h2 id="s:pck-programming">7.1) How Do Novices Program?</h2>
<p>[<a href="./bib.html#Solo1984">Solo1984</a>,<a href="./bib.html#Solo1986">Solo1986</a>] pioneered the exploration of novice and expert programming strategies. The key finding is that experts have both sufficient syntactic knowledge to write programs and a set of patterns or plans to guide their construction. Novices lack both, but we often focus solely on gaps in the former. For example, bugs are often related to planning errors (i.e., lack of a strategy for solving the problem) rather than to lack of knowledge about the language, so teachers should emphasize the “how” of program construction as much as the “what”. Having lots of plans or goals when programming isn’t always a good thing—as [<a href="./bib.html#Spoh1985">Spoh1985</a>] found, merging plans and/or goals can yield bugs because of goals being dropped or fragmented—but not having plans is always harmful.</p>
<blockquote>
<p><strong>The Rainfall Problem</strong></p>
<p>[<a href="./bib.html#Solo1986">Solo1986</a>] introduced the Rainfall Problem: write a program that repeatedly reads in positive integers until it reads the integer 99999. After seeing 99999, the program should print out the average of the numbers seen. This problem has been used in many subsequent studies of programming. For example, [<a href="./bib.html#Fisl2014">Fisl2014</a>] found that novices made fewer low-level errors when solving the problem in a pure functional language, but [<a href="./bib.html#Sepp2015">Sepp2015</a>] still found that success rates were disappointingly low.</p>
<p>However, [<a href="./bib.html#Simo2013">Simo2013</a>] argues that the Rainfall Problem is harder for novices than it used to be because today’s programmers are not used to handling keyboard input, and “run until you see a sentinel” isn’t a pattern they are familiar with. Direct comparison with past cohorts may therefore be unfair.</p>
</blockquote>
<p>The most important recommendation in this chapter is therefore to teach solution patterns, i.e., to show learners <em>how</em> to tackle problems. This is consistent with the work on cognitive load theory presented in <a href="./load.html">Chapter 4</a>, and [<a href="./bib.html#Mull2007b">Mull2007b</a>] is just one of many studies proving its benefits.</p>
<p>When teaching solution patterns, emphasize the importance of small steps with frequent feedback. [<a href="./bib.html#Blik2014">Blik2014</a>] found that, “more experienced students were more likely to adopt an incremental coding strategy (trying to debug and advance their code without external help through myriad trial-and-error attempts), whereas novices would update their code in larger batches, copying and adapting code from sample programs and other external sources.” Similarly, [<a href="./bib.html#Cart2017">Cart2017</a>] found that high-performing novices spent a lot of time testing, while low performers spent much more time working on code with errors.</p>
<p>Another aspect of “how” that teachers should present and discuss is the order in which code is written. [<a href="./bib.html#Ihan2011">Ihan2011</a>] describes a tool for 2D Parsons Problems (i.e., ones in which code can be dragged horizontally as well as vertically). They found that experienced programmers often drag the method signature to the beginning, then add the majority of the control flow (i.e., loop statements, assignments, conditional statements), and only then add details like variable initialization and handling of corner cases. This out-of-order authoring is foreign to novices, who read and write code in the order it’s presented on the page; one of the benefits of live coding (<a href="./performance.html#s:performance-live">Section 8.4</a>) is that it gives them a chance to see the sequence that more advanced programmers actually use.</p>
<h3 id="roles-of-variables" class="unnumbered">Roles of Variables</h3>
<p>One body of work that I have found very useful in teaching programming plans to novices is the collection of single-variable design patterns in [<a href="./bib.html#Kuit2004">Kuit2004</a>,<a href="./bib.html#Byck2005">Byck2005</a>,<a href="./bib.html#Saja2006">Saja2006</a>]. Consistent with everything we know about worked examples and subgoals (<a href="./load.html">Chapter 4</a>), their creators found that labelling the parts of novices’ programs gave them a vocabulary to think with, and implicitly a set of programming plans for constructing code of their own. The patterns are listed on the <a href="http://saja.kapsi.fi/var_roles/">Roles of Variables website</a>, which also includes examples of each:</p>
<dl>
<dt>Fixed value:</dt>
<dd><p>A data item that does not get a new proper value after its initialization.</p>
</dd>
<dt>Stepper:</dt>
<dd><p>A data item stepping through a systematic, predictable succession of values.</p>
</dd>
<dt>Walker:</dt>
<dd><p>A data item traversing in a data structure.</p>
</dd>
<dt>Most-recent holder:</dt>
<dd><p>A data item holding the latest value encountered in going through a succession of unpredictable values, or simply the latest value obtained as input.</p>
</dd>
<dt>Most-wanted holder:</dt>
<dd><p>A data item holding the best or otherwise most appropriate value encountered so far.</p>
</dd>
<dt>Gatherer:</dt>
<dd><p>A data item accumulating the effect of individual values.</p>
</dd>
<dt>Follower:</dt>
<dd><p>A data item that gets its new value always from the old value of some other data item.</p>
</dd>
<dt>One-way flag:</dt>
<dd><p>A two-valued data item that cannot get its initial value once the value has been changed.</p>
</dd>
<dt>Temporary:</dt>
<dd><p>A data item holding some value for a very short time only.</p>
</dd>
<dt>Organizer:</dt>
<dd><p>A data structure storing elements that can be rearranged.</p>
</dd>
<dt>Container:</dt>
<dd><p>A data structure storing elements that can be added and removed.</p>
</dd>
</dl>
<h2 id="s:pck-debug">7.2) How Do Novices Debug and Test?</h2>
<p>A decade ago, [<a href="./bib.html#McCa2008">McCa2008</a>] wrote, “It is surprising how little page space is devoted to bugs and debugging in most introductory programming textbooks.” Little has changed since, either in teaching or for professionals: while there are literally hundreds of textbooks on topics like compilers and operating systems, only a handful of books have ever been written about debugging, and I have never seen an undergraduate course on the subject.</p>
<p>One reason for this absence is that it debugging is a “knowing how” rather than a “knowing that”; one of the benefits of live coding is that it gives the instructor a chance to demonstrate the process in a way that textbooks cannot (<a href="./performance.html#s:performance-live">Section 8.4</a>).</p>
<p>[<a href="./bib.html#Fitz2008">Fitz2008</a>,<a href="./bib.html#Murp2008">Murp2008</a>] found that good debuggers were good programmers, but not all good programmers were good at debugging; those who were used a symbolic debugger to step through their programs, traced execution by hand, wrote tests, and re-read the spec. However, tracing execution step by step was sometimes used ineffectively: for example, a novice might put the same <code>print</code> statement in both parts of an <code>if</code>-<code>else</code>. Novices would also comment out lines that were actually correct in an attempt to isolate the problem, and didn’t seem to realize when they were stuck.</p>
<p>More recently, [<a href="./bib.html#Alqa2017">Alqa2017</a>] picked eight bugs, such as creating a loop without a body, and wrote one program for each that contained only that bug and could be fixed by modifying a single line. They then collected data from 142 novices doing their second programming course to categorize their debugging activities. Unsurprisingly, learners with more experience solved the problems significantly faster, but times varied widely: 4–10 minutes was a typical range for individual exercises, which means that some learners need 2–3 times longer than others to get through the same exercises.</p>
<p>Debugging depends on being able to read code, and multiple studies have shown that reading code is the single most effective way to find bugs [<a href="./bib.html#Basi1987">Basi1987</a>,<a href="./bib.html#Keme2009">Keme2009</a>,<a href="./bib.html#Bacc2013">Bacc2013</a>]. Having learners read code and summarize its behavior is a good homework exercise (<a href="./individual.html#s:individual-strategies">Section 5.1</a>), while having them predict its output just before it is run helps reinforce learning when live coding is used (<a href="./classroom.html#s:classroom-practices">Section 9.11</a>). The most useful resource I have found for this is the code quality rubric developed in [<a href="./bib.html#Steg2014">Steg2014</a>,<a href="./bib.html#Steg2016a">Steg2016a</a>], which is online at [<a href="./bib.html#Steg2016b">Steg2016b</a>].</p>
<p>Debugging also depends on being able to trace a program’s execution step by step. [<a href="./bib.html#List2004">List2004</a>] tested novices’ ability to predict the output of short pieces of code and to select the correct completion of the code from a set of possibilities when told what it was supposed to do. Many novices struggled, which suggests that not being able to trace execution is part of the explanation for poor programming ability.</p>
<p>[<a href="./bib.html#List2009">List2009</a>] returned to this subject, and found once again that novices who perform well at writing code can usually also trace and explain code. [<a href="./bib.html#Harr2018">Harr2018</a>] later found that the gap between being able to trace code and being able to write it has largely closed by CS2, but that novices who still have a gap (in either direction) are likely to do poorly in the course. Live coding (<a href="./performance.html#s:performance-live">Section 8.4</a>) makes it easy for the instructor to show learners how to trace code both before and after running it; instructors can also sketch changes to variables as they go along, which [<a href="./bib.html#Cunn2017">Cunn2017</a>] found was effective.</p>
<p>[<a href="./bib.html#Chi1989">Chi1989</a>] found that some learners simply halt when they hit an unexplained step (or a step whose explanation they don’t understand) when doing mechanics problems in a physics class. Others who pause their “execution” of the example to generate an explanation of what’s going on learn faster. Instructors should therefore demonstrate the latter strategy to learners.</p>
<p>When it comes to testing, novices seem just as reluctant to do it as professional programmers (many of whom would rather spend a week debugging than a day writing tests). Instructors can require learners to write tests for assignments; the question is, how well do they do this?</p>
<p>One answer comes from [<a href="./bib.html#Bria2015">Bria2015</a>], which scored learners’ programs by how many teacher-provided test cases those programs passed, and conversely scores test cases written by learners according to how many bugs they caught in model solutions deliberately seeded with errors. They found that novices’ tests often have low coverage (i.e., they don’t test most of the code) and that they often test many things at once, which makes it hard to pinpoint the causes of errors.</p>
<p>Another answer comes from [<a href="./bib.html#Edwa2014b">Edwa2014b</a>], which looked at all of the bugs in all novices’ code submissions combined and identified those detected by the novices’ test suite. They found that novices’ tests only detected an average of 13.6% of the faults present in the entire program population. What’s more, 90% of the novices’ tests were very similar, which indicates that novices mostly write tests to confirm that code is doing what it’s supposed to rather than to find cases where it isn’t.</p>
<p>The solution seems obvious: have learners write more tests, or define the work they’re supposed to do by giving them a set of tests and asking them to write code that passes. Before doing this, though, take a moment to look at how many tests you’ve written for your own code recently, and then decide whether you’re teaching what you believe people should do, or what they (and you) actually do.</p>
<h2 id="s:pck-misunderstand">7.3) What Misconceptions Do Novices Have?</h2>
<p>Clearing up novices misconceptions is just as important as teaching them strategies for solving problems (<a href="./models.html">Chapter 2</a>). The biggest misconception novices have—sometimes called the “superbug” in coding—is the belief that they can communicate with a computer in the same way that they would with a human being, i.e., that the computer understands intention the way that a human being would [<a href="./bib.html#Pea1986">Pea1986</a>]. As paradoxical as it sounds, it’s crucial to teach novices that programs are meaningless, i.e., that calling a variable “cost” doesn’t mean anything, and certainly doesn’t guarantee that its value is actually a cost.</p>
<p>[<a href="./bib.html#Sorv2018">Sorv2018</a>] presents over 40 specific misconceptions, many of which are also discussed in [<a href="./bib.html#Qian2017">Qian2017</a>]’s lengthier survey. One common one is the belief that variables in programs work the same way they do in spreadsheets, i.e., that after executing:</p>
<pre><code>grade = 65
total = grade + 10
grade = 80
print(total)</code></pre>
<p>the value of <code>total</code> will be 90 rather than 75 [<a href="./bib.html#Kohn2017">Kohn2017</a>]. This is an example of the way in which novices construct a plausible-but-wrong mental model by making analogies (<a href="./models.html">Chapter 2</a>), so lessons should include formative assessments early on to detect and correct this.</p>
<p>Another misconception [<a href="./bib.html#Koli2008">Koli2008</a>] found is that novices rarely consider programs absolutely incorrect, but are instead much more likely to consider them “partially correct” if they have any correct operations, probably a result of thinking in terms of grading schemes. This should be addressed early, along with others including:</p>
<ul>
<li>A variable holds the history of the values it has been assigned, i.e., it remembers what its value used to be.</li>
<li>Two objects with the same value for a <code>name</code> or <code>id</code> attribute are guaranteed to be the same object.</li>
<li>Functions are executed as they are defined, or are executed in the order in which they are defined.</li>
<li>A <code>while</code> loop’s condition is constantly evaluated, and the loop stops as soon as it becomes false. Conversely, the conditions in <code>if</code> statements are also constantly evaluated, and their statements are executed as soon as the condition becomes true, no matter where the flow of control is at the time.</li>
<li>Assignment moves values, i.e., after <code>a = b</code>, the variable <code>b</code> is empty.</li>
</ul>
<p>[<a href="./bib.html#Qian2017">Qian2017</a>] lists factors that contribute to these misconceptions, including:</p>
<ul>
<li>Learners being confused by the special technical meaning of jargon terms (such as “or” meaning “either or both” rather than “one or the other”).</li>
<li>Variable assignment looking like an algebraic expression (although [<a href="./bib.html#Brow2018">Brow2018</a>] found this to be less important than many educators think).</li>
<li>Confusing syntax, such as using <code>+</code> for addition and concatenation.</li>
<li>Misinterpreting teachers’ explanations: for example, if a teacher says that a variable is like a box, the learner may assume that means many things can be put in it.</li>
</ul>
<p>[<a href="./bib.html#Qian2017">Qian2017</a>] also includes larger issues, such as inadequate patterns and strategies, which is often characterized by phrases like, “I don’t know where to start” or “I can’t think at that level of abstraction”. As well as using lots of examples and teach programming strategies explicitly, they recommend using better tools like blocks-based languages and program visualization, providing better error messages, and use automated assessment tools to give more feedback earlier. We discuss the first three later in this chapter, and the fourth in <a href="./online.html">Chapter 11</a>.</p>
<p>Instead of looking at misconceptions, [<a href="./bib.html#Muhl2016">Muhl2016</a>] analyzed 350 concept maps and compared those who had done a CS course and those who had not. Unsurprisingly, they found that the maps drawn by those with previous experience looked more like the maps experts would draw. The details highlighted what exactly learners were taking away from their lessons: “program” was a central concept in both sets of concept maps, but the next most central concepts for those with prior CS exposure were “class” and “data structure”, while for those without, they were “processor” and “data”.</p>
<h2 id="s:pck-mistakes">7.4) What Mistakes Do Novices Make?</h2>
<p>Novices demonstrate their misconceptions by making mistakes; the kinds of mistakes they make can tell us what to prioritize in our teaching, but research has found that most teachers don’t know how common different kinds of mistakes actually are. [<a href="./bib.html#Brow2018">Brow2018</a>] looked at eighteen types of errors, from mismatched parentheses to discarding the result of a method that returned a value and found that, “<span>…</span>educators formed only a weak consensus about which mistakes are most frequent, that their rankings bore only a moderate correspondence to the students in the<span>…</span>data, and that educators’ experience had no effect on this level of agreement.” For example, mistaking <code>=</code> (assignment) and <code>==</code> (equality) in loop condition tests wasn’t nearly as common as most teachers believed.</p>
<p>[<a href="./bib.html#Brow2018">Brow2018</a>] then looked at what errors novices actually make in Java. Unsurprisingly, mistakes that produce compiler errors are fixed much faster than ones that don’t. Mismatched quotes and parentheses are the most common type of error, but also the easiest to fix, while some mistakes (like putting the condition of an <code>if</code> in <code>{}</code> instead of <code>()</code>) are most often made only once. However, some mistakes are made many times, like invoking methods with the wrong arguments (e.g., passing a string instead of an integer). Findings like these aren’t specific to any particular language, but one caution when reading this research is how important it is to distinguish mistakes from work in progress: for example, an empty <code>if</code> statement or a method that’s defined but not yet used may be a sign of incomplete code rather than an error.</p>
<blockquote>
<p><strong>Not Just for Code</strong></p>
<p>[<a href="./bib.html#Park2015">Park2015</a>] collected data from an online HTML editor during an introductory web development course. Nearly all learners made syntax errors that remained unresolved weeks into the course. 20% of these errors related to the relatively complex rules that dictate <em>when</em> it is valid for HTML elements to be nested in one another, but 35% related to the simpler tag syntax determining <em>how</em> HTML elements are nested. (The tendency of many instructors to say, “But the rules are simple,” is a good example of expert blind spot discussed in <a href="./memory.html">Chapter 3</a><span>…</span>)</p>
</blockquote>
<h2 id="s:pck-now">7.5) What Are We Teaching Them Now?</h2>
<p>Very little is known about what coding bootcamps and other free-range initiatives teach, or how well, in part because many are reluctant to share their curriculum. We do know more about what is taught in schools: [<a href="./bib.html#Luxt2017">Luxt2017</a>] surveyed the topics included in introductory programming courses, categorized their findings under a dozen headings, and ranked them by frequency:</p>

<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">Topic</td>
<td style="text-align: right;">Number of Courses</td>
<td style="text-align: right;">(%)</td>
</tr>
<tr class="even">
<td style="text-align: left;">Programming Process</td>
<td style="text-align: right;">90</td>
<td style="text-align: right;">(87%)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Abstract Programming Thinking</td>
<td style="text-align: right;">65</td>
<td style="text-align: right;">(63%)</td>
</tr>
<tr class="even">
<td style="text-align: left;">Data Structures</td>
<td style="text-align: right;">41</td>
<td style="text-align: right;">(40%)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Object-Oriented Concepts</td>
<td style="text-align: right;">37</td>
<td style="text-align: right;">(36%)</td>
</tr>
<tr class="even">
<td style="text-align: left;">Control Structures</td>
<td style="text-align: right;">34</td>
<td style="text-align: right;">(33%)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Operations &amp; Functions</td>
<td style="text-align: right;">27</td>
<td style="text-align: right;">(26%)</td>
</tr>
<tr class="even">
<td style="text-align: left;">Data Types</td>
<td style="text-align: right;">24</td>
<td style="text-align: right;">(23%)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Input/Output</td>
<td style="text-align: right;">18</td>
<td style="text-align: right;">(17%)</td>
</tr>
<tr class="even">
<td style="text-align: left;">Libraries</td>
<td style="text-align: right;">15</td>
<td style="text-align: right;">(15%)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Variables &amp; Assignment</td>
<td style="text-align: right;">14</td>
<td style="text-align: right;">(14%)</td>
</tr>
<tr class="even">
<td style="text-align: left;">Recursion</td>
<td style="text-align: right;">10</td>
<td style="text-align: right;">(10%)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Pointers &amp; Memory Management</td>
<td style="text-align: right;">5</td>
<td style="text-align: right;">(5%)</td>
</tr>
</tbody>
</table>
<p>This paper did more than catalog concepts: it also showed how they are connected. For example, it’s impossible to explain how operator precedence works without first explaining a few operators, and hard to explain those in a meaningful way without first introducing variables (because otherwise you’re comparing constants in expressions like <code>5&lt;3</code>, which is confusing).</p>
<p>Similarly, [<a href="./bib.html#Rich2017">Rich2017</a>] reviewed a hundred articles to find learning trajectories for computing classes in elementary and middle schools, and presented results for sequencing, repetition, and conditionals. These are essentially collective concept maps, as they combine and rationalize the implicit and explicit thinking of many different educators. <a href="./pck.html#f:pck-trajectory">Figure 7.1</a> shows the learning trajectories for conditionals.</p>

<figure>
<img src="./fig/conditionals.svg" /><figcaption id="f:pck-trajectory">Figure 7.1: Learning Trajectory for Conditions (from [<a href="./bib.html#Rich2017">Rich2017</a>])</figcaption>
</figure>
<h2 id="s:pck-baseline">7.6) How Much Are Novices Learning?</h2>
<p>Study after study has shown that teaching evaluations don’t correlate with actual learning outcomes [<a href="./bib.html#Star2014">Star2014</a>,<a href="./bib.html#Uttl2017">Uttl2017</a>], so to find out how much novices are actually learning, we have to use other measures or do direct studies. Taking the former approach, roughly two-thirds of post-secondary students pass their first computing course, with some variations depending on class size and so on, but with no significant differences over time or based on language [<a href="./bib.html#Benn2007a">Benn2007a</a>,<a href="./bib.html#Wats2014">Wats2014</a>].</p>
<p>Taking the latter approach, [<a href="./bib.html#McCr2001">McCr2001</a>] presented a multi-site international study, which was later replicated by [<a href="./bib.html#Utti2013">Utti2013</a>]. According to the first study, “<span>…</span>the disappointing results suggest that many students do not know how to program at the conclusion of their introductory courses.” More specifically, “For a combined sample of 216 students from four universities, the average score was 22.89 out of 110 points on the general evaluation criteria developed for this study.” However, this may say as much about teachers’ expectations as it does about student ability.</p>
<p>A growing number of studies have looked at how prior experience affects these results. For example, [<a href="./bib.html#Wilc2018">Wilc2018</a>] compared the performance and confidence of novices with and without prior programming experience in CS1 and CS2. They found that novices with prior experience outscored novices without by 10% in CS1, but those differences disappeared by the end of CS2. They also found that women with prior exposure outperformed their male peers in all areas, but were consistently less confident in their abilities; we will return to this issue in <a href="./motivation.html#s:motivation-inclusivity">Section 10.4</a>.</p>
<h2 id="s:pck-language">7.7) Do Languages Matter?</h2>
<p>The short answer is “yes”: novices learn to program faster and also learn more using blocks-based tools like Scratch (<a href="./pck.html#f:pck-scratch">Figure 7.2</a>) that make syntax errors impossible [<a href="./bib.html#Wein2017b">Wein2017b</a>]. And block interfaces encourage exploration in a way that text does not; like all good tools, Scratch can be learned accidentally [<a href="./bib.html#Malo2010">Malo2010</a>].</p>

<figure>
<img src="./fig/scratch.jpg" alt="Figure 7.2: Scratch (from https://opensource.com/article/18/4/designing-game-scratch-open-jam)" /><figcaption id="f:pck-scratch">Figure 7.2: Scratch (from <a href="https://opensource.com/article/18/4/designing-game-scratch-open-jam" class="uri">https://opensource.com/article/18/4/designing-game-scratch-open-jam</a>)</figcaption>
</figure>
<p>[<a href="./bib.html#Mlad2017">Mlad2017</a>] studied 207 novices learning about loops in Scratch, Logo, and Python, and found that misconceptions about loops are minimized when using a block-based language rather than a text-based language. What’s more, as tasks become more complex (such as using nested loops) the differences become larger. Similarly, [<a href="./bib.html#Grov2017">Grov2017</a>] studied 100 middle-school children, they found that while it was easier for them to assemble programs with blocks than with text. However, some concepts are still intrinsically hard, such as loops that modify variables and logical <code>or</code> (which is often interpreted as “one or the other” rather than “one or both”).</p>
<p>Scratch has probably been studied more than any other programming tool, and we know a great deal about how it is used. For example, [<a href="./bib.html#Aiva2016">Aiva2016</a>] analyzed over 250,000 Scratch projects and found among other things that about 28% of projects have some blocks that are never called or triggered. The authors hypothesize that users may be using them as a scratchpad to keep bits of code they don’t (yet) want to throw away.</p>
<p>[<a href="./bib.html#Wein2017a">Wein2017a</a>] studied people using a tool that allowed them to switch between blocks and text for programming. They found that learners tend to migrate from blocks to text over time, but there are interesting exceptions. In two thirds of the cases where learners shifted from text to blocks, their next action was to add a new type of command; this may be because browsing available commands is easier with blocks, or because blocks make syntax errors with unfamiliar new commands impossible.</p>
<p>Learners also shifted from text to blocks when adding complex control (e.g., an <code>if</code> with an <code>else</code>), either because syntax errors are harder, or because the flow of control is immediately visible. The authors say, “While it is often claimed that blocks-based programming environments offer the advantage of reducing syntax errors, our findings suggest that blocks also offer information about what is possible in the space and provide a low-stakes means of exploring unfamiliar code.” New tools like <a href="https://www.greenfoot.org/frames/">Stride</a> are trying to smooth the transition between blocks and text even further; when combined with programming notebooks like <a href="http://jupyter.org/">Jupyter</a> and <a href="http://stenci.la/">Stencila</a>, they may eventually eliminate the distinction altogether.</p>
<h3 id="object-oriented-programming-and-functional-programming" class="unnumbered">Object-Oriented Programming and Functional Programming</h3>
<p>Objects and classes are power tools for experienced programmers, and many educators advocate an “objects first” approach to teaching programming (though they sometimes disagree on exactly what that means [<a href="./bib.html#Benn2007b">Benn2007b</a>]). [<a href="./bib.html#Sorv2014">Sorv2014</a>] describes and motivates this approach, and [<a href="./bib.html#Koll2015">Koll2015</a>] describes three generations of tools designed to support novice programming in object-oriented environments.</p>
<p>Introducing objects early has a few challenges. For example, [<a href="./bib.html#Mill2016b">Mill2016b</a>] found that most novices using Python had difficulty with <code>self</code> (which refers to “this object”): they omitted it in method definitions, failed to use it when referencing object attributes, or both. Object reference errors were also more common than other errors; the authors speculate that this is partly due to the difference in syntax between <code>obj.method(param)</code> and <code>def method(self, param)</code>. [<a href="./bib.html#Rago2017">Rago2017</a>] found something similar in a study of 86 high school students. They also found that high school teachers often weren’t clear on the concept either.</p>
<p>Yet another approach is exemplified by the <a href="http://www.bootstrapworld.org/">Bootstrap project</a>, which is based on the <a class="glossref" href="./gloss.html#g:functional-programming"><strong>functional programming</strong></a> paradigm. This work draws on a rich tradition going back to languages like Scheme and Lisp, and to classic textbooks like [<a href="./bib.html#Fell2001">Fell2001</a>], [<a href="./bib.html#Frie1995">Frie1995</a>], and [<a href="./bib.html#Abel1996">Abel1996</a>]. As functional programming continues to gain ground among professional programmers, this approach to teaching may continue to grow more popular.</p>
<h3 id="type-declarations" class="unnumbered">Type Declarations</h3>
<p>Programmers argue a lot about whether variables’ data types should have to be declared or not. One recent non-educational finding is [<a href="./bib.html#Gao2017">Gao2017</a>], which selected fixed bugs from public JavaScript projects, checked out the code from version control just prior to the fix, manually added type annotations to the buggy code, and then tested whether strongly-typed variants of JavaScript reported an error. They found that about 15% of bugs are caught, which is either high or low depending on what answer you wanted in the first place.</p>
<p>However, programming and learning to program are different activities, and results from the former don’t necessarily apply to the latter. [<a href="./bib.html#Endr2014">Endr2014</a>] found that requiring novices to declare variable types does add some complexity to programs, but it pays off fairly quickly by acting as documentation for a method’s use—in particular, by forestalling questions about what’s available and how to use it.</p>
<h3 id="will-things-get-better" class="unnumbered">Will Things Get Better?</h3>
<p>[<a href="./bib.html#Stef2013">Stef2013</a>] has shown that the creators of programming language make those languages harder to learn by not doing basic usability testing. For example, “<span>…</span>the three most common words for looping in computer science, <code>for</code>, <code>while</code>, and <code>foreach</code>, were rated as the three most unintuitive choices by non-programmers.” More fundamentally, their work shows that C-style syntax (as used in Java and Perl) is just as hard for novices to learn as a randomly-designed syntax, but that the syntax of languages such as Python and Ruby is significantly easier to learn, and the syntax of their own language, Quorum, is easier still, because they are testing each new feature before adding it to the language. ([<a href="./bib.html#Stef2017">Stef2017</a>] is a useful brief summary of what we actually know about designing programming languages and why we believe it’s true.)</p>
<p>However, none of this matters unless designers are willing to take it into account, and they are often reluctant to do so. For example, [<a href="./bib.html#Pere2013">Pere2013</a>] compared the actual operation of Git (a popular version control system) with its users’ conceptual model, highlighting and explaining the many errors and confusion that result from the differences. [<a href="./bib.html#Pere2016">Pere2016</a>] then used that work to design a more user-friendly alternative to Git. The result?</p>
<blockquote>
<p>In sharing our research with colleagues<span>…</span>we have discovered a significant polarization. Experts, who are deeply familiar with the product, have learned its many intricacies, developed complex, customized workflows, and regularly exploit its most elaborate features, are often defensive and resistant to the suggestion that the design has flaws. In contrast, less intensive users, who have given up on understanding the product, and rely on only a handful of memorized commands, are so frustrated by their experience that an analysis like ours seems to them belaboring the obvious.</p>
</blockquote>
<h2 id="s:pck-error">7.8) Can We Give Better Feedback?</h2>
<p>Incomprehensible error messages are a major source of frustration for novices (and sometimes for experienced programmers as well). Several researchers have explored whether better error messages would help alleviate this. For example, [<a href="./bib.html#Beck2016">Beck2016</a>] wrote some for the Java compiler so that instead of:</p>
<pre><code>C:\stj\Hello.java:2: error: cannot find symbol
        public static void main(string[ ] args){
^
1 error
Process terminated ... there were problems.</code></pre>
<p>learners would see:</p>
<pre><code>Looks like a problem on line number 2.
If &quot;string&quot; refers to a datatype, capitalize the &#39;s&#39;!</code></pre>
<p>Novices given these messages made fewer repeated errors and fewer errors overall.</p>
<p>[<a href="./bib.html#Bari2017">Bari2017</a>] went further and used eye tracking to show that despite the grumblings of compiler writers, people really do read error messages—in fact, they spend 13–25% of their time on task doing this. Reading error messages turns out to be as difficult as reading source code, and how difficult it is to read the error messages strongly predicts task performance. The inescapable conclusion is that it really is important to get this right, and that error messages should be usability tested the same way as any other interface.</p>
<p>Since interpreting and responding to error messages is important, instructors should give learners exercises that do just that. [<a href="./bib.html#Marc2011">Marc2011</a>] has a rubric for responses to error messages that can be useful in grading such exercises.</p>
<h2 id="s:pck-code">7.9) Does Variable Naming Style Matter?</h2>
<p>[<a href="./bib.html#Kern1999">Kern1999</a>] says, “Programmers are often encouraged to use long variable names regardless of context. This is a mistake: clarity is often achieved through brevity.” Lots of programmers believe this, but [<a href="./bib.html#Hofm2017">Hofm2017</a>] found that using full words in variable names led to an average of 19% faster comprehension compared to letters and abbreviations, with no significant difference in speed between single letters and abbreviations, but didn’t look at <em>which</em> names were abbreviated.</p>
<p>For that, we have to turn to [<a href="./bib.html#Beni2017">Beni2017</a>], which found that using single-letter variable names doesn’t affect novice programmers’ ability to modify code. This may be because novices’ programs are shorter than professionals’, but it may also be because some single-letter variable names have implicit types and meanings: most programmers assume <code>i</code>, <code>j</code>, and <code>n</code> are integers, and <code>s</code> is a string, while <code>x</code>, <code>y</code>, and <code>z</code> are either floating-point numbers or integers more or less equally.</p>
<p>How important is this? [<a href="./bib.html#Bink2012">Bink2012</a>] reported a series of studies that found that reading and understanding code is fundamentally different from reading prose: “<span>…</span>the more formal structure and syntax of source code allows programmers to assimilate and comprehend parts of the code quite rapidly independent of style. In particular<span>…</span>beacons and program plans play a large role in comprehension.” It also found that experienced developers are relatively unaffected by identifier style (although again, they didn’t explore <em>which</em> variables), and that beginners found CamelCase easier to read than pothole_case. This is surprising because word spacing improves readability in conventional tasks. Digging deeper, “<span>…</span>camel casing produces more accurate results. However, this correctness comes at a cost as the camel-case style significantly increases the time needed to correctly detect the correct identifier.”</p>
<h2 id="s:pck-visualization">7.10) Does Visualization Help?</h2>
<p>The idea of visualizing programs is perennially popular, and tools like [<a href="./bib.html#Guo2013">Guo2013</a>] (a web-based tool for visualizing the execution of Python programs) and <a href="http://latentflip.com/loupe/">Loupe</a> (which shows how JavaScript’s event loop works) are both popular teaching aids. However, we have known for over 20 years that people learn more from constructing visualizations than they do from viewing visualizations constructed by others [<a href="./bib.html#Stas1998">Stas1998</a>,<a href="./bib.html#Ceti2016">Ceti2016</a>], so does visualization actually helping learning?</p>
<p>To answer this, [<a href="./bib.html#Cunn2017">Cunn2017</a>] replicated an earlier study of the kinds of sketching students do when tracing code execution, and correlations between different kinds and effectiveness. Different rates of sketching for different problems indicated that students use it to externalize cognition; not sketching at all correlates with lower success, while tracing changes to variables’ values by writing new values near their names as they change was the most effective strategy.</p>
<p>One possible confounding effect they checked was time: since sketchers take significantly more time to solve problems, do they do better just because they think for longer? The answer is no: there was no correlation between the time taken and the score achieved. To the best of my knowledge, nobody has yet built a debugger that shows successive values for variables laid out in rows, but this research suggests that something like that could help.</p>
<blockquote>
<p><strong>Flowcharts</strong></p>
<p>One often-overlooked finding about visualization is that students understand flowcharts better than pseudocode <em>if both are equally well structured</em> [<a href="./bib.html#Scan1989">Scan1989</a>]. Earlier work showing that pseudocode outperformed flowcharts used structured pseudocode and tangled flowcharts; when the playing field was levelled, novices did better with the graphical representation.</p>
</blockquote>
<h2 id="s:pck-help">7.11) What Else Can We Do to Help?</h2>
<p>[<a href="./bib.html#Viha2014">Viha2014</a>] examined the average improvement in pass rates of various kinds of intervention in programming classes. As they themselves point out, there are many reasons to take their findings with a grain of salt: the pre-change teaching practices are rarely stated clearly, the quality of change is not judged, and only 8.3% of studies reported negative findings, so either there is positive reporting bias or the way we’re teaching right now is almost the worst way possible and anything would be an improvement. It’s also worth remembering that like almost all of the studies discussed in this chapter, they were only looking at university classes: their findings may not generalize to other groups.</p>
<p>With all those caveats in mind, they found ten things instructors can do to improve outcomes. <a href="./pck.html#f:pck-interventions">Figure 7.3</a> shows the average improvement reported for each type:</p>
<dl>
<dt>Collaboration:</dt>
<dd><p>Activities that encourage student collaboration either in classrooms or labs.</p>
</dd>
<dt>Content Change:</dt>
<dd><p>Parts of the teaching material were changed or updated.</p>
</dd>
<dt>Contextualization:</dt>
<dd><p>Course content and activities were aligned towards a specific context such as games or media.</p>
</dd>
<dt>CS0:</dt>
<dd><p>Creation of a preliminary course to be taken before the introductory programming course; could be organized only for some (e.g., at-risk) students.</p>
</dd>
<dt>Game Theme:</dt>
<dd><p>A game-themed component was introduced to the course.</p>
</dd>
<dt>Grading Scheme:</dt>
<dd><p>A change in the grading scheme; the most common change was to increase the amount of points rewarded from programming activities, while reducing the weight of the course exam.</p>
</dd>
<dt>Group Work:</dt>
<dd><p>Activities with increased group work commitment such as team-based learning and cooperative learning.</p>
</dd>
<dt>Media Computation:</dt>
<dd><p>Activities explicitly declaring the use of media computation (<a href="./motivation.html">Chapter 10</a>).</p>
</dd>
<dt>Peer Support:</dt>
<dd><p>Support by peers in form of pairs, groups, hired peer mentors or tutors.</p>
</dd>
<dt>Other Support:</dt>
<dd><p>An umbrella term for all support activities, e.g. increased teacher hours, additional support channels, etc.</p>
</dd>
</dl>

<figure>
<img src="./fig/interventions.png" alt="Figure 7.3: Effectiveness of Interventions" /><figcaption id="f:pck-interventions">Figure 7.3: Effectiveness of Interventions</figcaption>
</figure>
<p>This list highlights the importance of cooperative learning. [<a href="./bib.html#Beck2013">Beck2013</a>] looked at this specifically over three academic years in courses taught by two different instructors, and found significant benefits overall and for many subgroups: they not only had higher grades, they left fewer questions blank on the final exam, which indicates greater self-efficacy and willingness to try to debug things.</p>
<p>As noted earlier, writing code isn’t the only way to teach people how to program. [<a href="./bib.html#Shel2017">Shel2017</a>] reports that having novices work on computational creativity exercises improves grades at several levels. A typical exercise is to identify an everyday object (such as nail clipper, a paper clip, Scotch tape) and describe the object in terms of its inputs, outputs and functions. This kind of teaching is sometimes called “unplugged”, and the <a href="https://csunplugged.org/en/">CS Unplugged</a> site has a collection of lessons and exercises for doing this.</p>
<h2 id="s:pck-exercises">7.12) Exercises</h2>
<h3 id="checking-for-common-errors-individual20-minutes" class="unnumbered">Checking for Common Errors (<span>individual</span>/<span>20</span> minutes)</h3>
<p>This list of common errors is taken from [<a href="./bib.html#Sirk2012">Sirk2012</a>]. Pick three, and write an exercise for each to check that learners <em>aren’t</em> making that mistake.</p>
<dl>
<dt>Inverted assignment:</dt>
<dd><p>The student assigns the value of the left-hand variable to the right-hand side variable, rather than the other way around.</p>
</dd>
<dt>Wrong branch:</dt>
<dd><p>Even though the conditional evaluates to <code>False</code>, the student jumps to the <code>then</code> clause.</p>
</dd>
<dt>Wrong <code>False</code>:</dt>
<dd><p>As soon as the conditional evaluates to <code>False</code> , the student returns <code>False</code> from the function.</p>
</dd>
<dt>Executing function instead of defining it:</dt>
<dd><p>The student believes that a function is executed as it is defined.</p>
</dd>
<dt>Unevaluated parameters:</dt>
<dd><p>The student believes the function starts running before the parameters have been evaluated.</p>
</dd>
<dt>Parameter evaluated in the wrong frame:</dt>
<dd><p>The student creates parameter variables in the caller’s frame, not in the callee’s.</p>
</dd>
<dt>Failing to store return value:</dt>
<dd><p>The student does not assign the return value in the caller.</p>
</dd>
<dt>Assignment copies object:</dt>
<dd><p>The student creates a new object rather than copying a reference.</p>
</dd>
<dt>Method call without subject:</dt>
<dd><p>The student tries to call a method from a class without first creating an instance of the class.</p>
</dd>
</dl>
<h3 id="mangled-code-pairs15-minutes" class="unnumbered">Mangled Code (<span>pairs</span>/<span>15</span> minutes)</h3>
<p>[<a href="./bib.html#Chen2017">Chen2017</a>] describes exercises in which students reconstruct code that has been mangled by removing comments, deleting or replacing lines of code, moving lines, inserting extra unneeded lines, and so on. Student performance on these correlates strongly with performance on assessments in which students write code (i.e., whatever traditional assignments are measuring, these are measuring as well), but these questions require less (in-person) work to mark. Take the solution to a programming exercise you’ve created in the past, mangle it in two different ways, and swap with a partner.</p>
<h3 id="the-rainfall-problem-pairs10-minutes" class="unnumbered">The Rainfall Problem (<span>pairs</span>/<span>10</span> minutes)</h3>
<p>Solve the Rainfall Problem in the programming language of your choice in two different ways. Compare your solutions with those of your partner.</p>
<h3 id="roles-of-variables-pairs15-minutes" class="unnumbered">Roles of Variables (<span>pairs</span>/<span>15</span> minutes)</h3>
<p>Take a short program you have written (5–15 lines) and classify each of its variables using the categories defined in <a href="./pck.html#s:pck-programming">Section 7.1</a>. Compare your classifications with those of a partner: where did you agree? When you disagreed, did you understand each other’s view?</p>
<h3 id="choose-your-own-adventures-individual10-minutes" class="unnumbered">Choose Your Own Adventures (<span>individual</span>/<span>10</span> minutes)</h3>
<p>Which of the three approaches described in [<a href="./bib.html#Sorv2014">Sorv2014</a>] (<a href="./pck.html#s:pck-now">Section 7.5</a>) do you use when teaching? Or is your approach best described in some other way?</p>
<h3 id="what-are-you-teaching-individual10-minutes" class="unnumbered">What Are You Teaching? (<span>individual</span>/<span>10</span> minutes)</h3>
<p>Compare the topics you teach to the list developed in [<a href="./bib.html#Luxt2017">Luxt2017</a>] (<a href="./pck.html#s:pck-now">Section 7.5</a>). Which topics do you cover? What extra topics do you cover that aren’t in their list?</p>
<h3 id="beneficial-activities-individual10-minutes" class="unnumbered">Beneficial Activities (<span>individual</span>/<span>10</span> minutes)</h3>
<p>Look at the list of interventions developed by [<a href="./bib.html#Viha2014">Viha2014</a>] (<a href="./pck.html#s:pck-help">Section 7.11</a>). Which of these things do you already do in your classes? Which ones could you easily add? Which ones are irrelevant?</p>
<h3 id="visualizations-individual10-minutes" class="unnumbered">Visualizations (<span>individual</span>/<span>10</span> minutes)</h3>
<p>What visualization do you most like to use when teaching? Is it a static image or an animation? Do you show it to your learners, do they discover it on their own, or something in between?</p>
<h3 id="misconceptions-and-challenges-small-groups15-minutes" class="unnumbered">Misconceptions and Challenges (<span>small groups</span>/<span>15</span> minutes)</h3>
<p>The <a href="http://www.pd4cs.org/">Professional Development for CS Principles Teaching</a> site includes <a href="http://www.pd4cs.org/mc-index/">a detailed list of student misconceptions and exercises</a>. Working in small groups, choose one section (such as data structures or functions) and go through their list. Which of these misconceptions do you remember having when you were a learner? Which do you still have? Which have you seen in your learners?</p>
